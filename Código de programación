/*****************************************************************************************************************
	UNIVERSIDAD NACIONAL AUTONOMA DE MEXICO
	FACULTAD DE ESTUDIOS SUPERIORES -ARAGON-

	Computadoras y programacion. 
	(c) Karen Paola Espinoza Altamirano 323296885
	
	Quiso decir: Programa principal de la aplicacion de la distancia de Levenstein.
	
******************************************************************************************************************/

#include "stdafx.h"
#include <string.h>
#include "corrector.h"
#include <ctype.h>
//Funciones publicas del proyecto
/*****************************************************************************************************************
	DICCIONARIO: Esta funcion crea el diccionario completo
	char *	szNombre				:	Nombre del archivo de donde se sacaran las palabras del diccionario	
	char	szPalabras[][TAMTOKEN]	:	Arreglo con las palabras completas del diccionario
	int		iEstadisticas[]			:	Arreglo con el numero de veces que aparecen las palabras en el diccionario
	int &	iNumElementos			:	Numero de elementos en el diccionario
******************************************************************************************************************/
void Diccionario(char* szNombre, char szPalabras[][TAMTOKEN], int iEstadisticas[], int& iNumElementos)

{

    FILE* f = fopen(szNombre, "r");

    iNumElementos = 0;



    if (f == NULL)

    {

        iNumElementos = 0;

    }

    else

    {

        char palabra[TAMTOKEN];

        int c;

        int idx = 0;

        while (1)

        {

            c = fgetc(f);

            if (c == EOF)

            {

                if (idx > 0)

                {

                    palabra[idx] = '\0';

                    for (int q = 0; q < idx; q++)

                    {

                        if (palabra[q] >= 'A' && palabra[q] <= 'Z')

                            palabra[q] += 32;

                    }

                    int existe = 0;

                    int pos = 0;

                    for (int k = 0; k < iNumElementos; k++)

                    {

                        if (strcmp(palabra, szPalabras[k]) == 0)

                        {

                            existe = 1;

                            pos = k;

                            k = iNumElementos;

                        }

                    }


                    if (existe == 1)

                        iEstadisticas[pos]++;

                    else

                    {

                        strcpy_s(szPalabras[iNumElementos], palabra);

                        iEstadisticas[iNumElementos] = 1;

                        iNumElementos++;

                    }

                }

                break;

            }

            if (c == ' ' || c == '\n' || c == '\t' || c == '\r' || c == ',' || c == ';' || c == '(' || c == ')')

            {

                if (idx > 0)

                {

                    palabra[idx] = '\0';



                    for (int q = 0; q < idx; q++)

                    {

                        if (palabra[q] >= 'A' && palabra[q] <= 'Z')

                            palabra[q] += 32;

                    }



                    int existe = 0;

                    int pos = 0;

                    for (int k = 0; k < iNumElementos; k++)

                    {

                        if (strcmp(palabra, szPalabras[k]) == 0)

                        {

                            existe = 1;

                            pos = k;

                            k = iNumElementos;

                        }

                    }


                    if (existe == 1)

                        iEstadisticas[pos]++;

                    else

                    {

                        strcpy_s(szPalabras[iNumElementos], palabra);

                        iEstadisticas[iNumElementos] = 1;

                        iNumElementos++;

                    }

                    idx = 0;

                }

            }

            else

            {

                if (idx < TAMTOKEN - 1)

                {

                    palabra[idx] = (char)c;

                    idx++;

                }

            }

        }

        fclose(f);

    }

    // ORDENAMIENTO BURBUJA
    for (int i = 0; i < iNumElementos; i++)

    {

        for (int j = 0; j < iNumElementos - 1; j++)

        {

            if (strcmp(szPalabras[j], szPalabras[j + 1]) > 0)

            {

                char temp[TAMTOKEN];

                strcpy_s(temp, szPalabras[j]);

                strcpy_s(szPalabras[j], szPalabras[j + 1]);

                strcpy_s(szPalabras[j + 1], temp);



                int t = iEstadisticas[j];

                iEstadisticas[j] = iEstadisticas[j + 1];

                iEstadisticas[j + 1] = t;

            }

        }

    }

}
/*****************************************************************************************************************
	ListaCandidatas: Esta funcion recupera desde el diccionario las palabras validas y su peso
	Regresa las palabras ordenadas por su peso
	char	szPalabrasSugeridas[][TAMTOKEN],	//Lista de palabras clonadas
	int		iNumSugeridas,						//Lista de palabras clonadas
	char	szPalabras[][TAMTOKEN],				//Lista de palabras del diccionario
	int		iEstadisticas[],					//Lista de las frecuencias de las palabras
	int		iNumElementos,						//Numero de elementos en el diccionario
	char	szListaFinal[][TAMTOKEN],			//Lista final de palabras a sugerir
	int		iPeso[],							//Peso de las palabras en la lista final
	int &	iNumLista)							//Numero de elementos en la szListaFinal
******************************************************************************************************************/
void ListaCandidatas(
    char    szPalabrasSugeridas[][TAMTOKEN],
    int     iNumSugeridas,
    char    szPalabras[][TAMTOKEN],
    int     iEstadisticas[],
    int     iNumElementos,
    char    szListaFinal[][TAMTOKEN],
    int     iPeso[],
    int& iNumLista)
{
    iNumLista = 0; // Reiniciamos el contador

    // 1) Cruzar listas verificando duplicados y existencia en diccionario
    for (int s = 0; s < iNumSugeridas; s++) {

        // A. Verificar si ya existe en la lista final 
        int yaExiste = 0; // Bandera de control
        int k = 0;
        while (k < iNumLista && !yaExiste) {
            if (strcmp(szListaFinal[k], szPalabrasSugeridas[s]) == 0) {
                yaExiste = 1; // Esto hará que el while termine en la sig. iteración
            }
            k++;
        }

        // B. Si no existe, buscamos en el diccionario 
        if (!yaExiste) {
            int r = 0;
            int encontradoEnDic = 0; // Bandera para detener búsqueda

            while (r < iNumElementos && !encontradoEnDic) {
                // Si coincide la palabra
                if (strcmp(szPalabras[r], szPalabrasSugeridas[s]) == 0) {

                    // Guardamos si hay espacio
                    if (iNumLista < NUMPALABRAS) {
                        strcpy_s(szListaFinal[iNumLista], TAMTOKEN, szPalabras[r]);
                        iPeso[iNumLista] = iEstadisticas[r];
                        iNumLista++;
                    }
                    encontradoEnDic = 1; 
                }
                r++;
            }
        }
    }

    // 2) Ordenar 
    for (int a = 0; a < iNumLista - 1; a++) {
        int maxIdx = a;

        for (int b = a + 1; b < iNumLista; b++) {
            if (iPeso[b] > iPeso[maxIdx]) {
                maxIdx = b;
            }
        }

        if (maxIdx != a) {
            int tempPeso = iPeso[a];
            iPeso[a] = iPeso[maxIdx];
            iPeso[maxIdx] = tempPeso;

            char tempStr[TAMTOKEN];
            strcpy_s(tempStr, TAMTOKEN, szListaFinal[a]);
            strcpy_s(szListaFinal[a], TAMTOKEN, szListaFinal[maxIdx]);
            strcpy_s(szListaFinal[maxIdx], TAMTOKEN, tempStr);
        }
    }
}

/*****************************************************************************************************************
	ClonaPalabras: toma una palabra y obtiene todas las combinaciones y permutaciones requeridas por el metodo
	char *	szPalabraLeida,						// Palabra a clonar
	char	szPalabrasSugeridas[][TAMTOKEN], 	//Lista de palabras clonadas
	int &	iNumSugeridas)						//Numero de elementos en la lista
******************************************************************************************************************/

void ClonaPalabras(char* szPalabraLeida, char szPalabrasSugeridas[][TAMTOKEN], int& iNumSugeridas)
{
    iNumSugeridas = 0;
    size_t len = strlen(szPalabraLeida);
    char temp[TAMTOKEN];

    strcpy(szPalabrasSugeridas[iNumSugeridas], szPalabraLeida);
    iNumSugeridas++;

    // SUPRESION
    for (int i = 0; i < len; i++)
    {
        int p = 0;
        for (int j = 0; j < len; j++)
        {
            if (j != i)
            {
                temp[p] = szPalabraLeida[j];
                p++;
            }
        }
        temp[p] = '\0';
        strcpy(szPalabrasSugeridas[iNumSugeridas], temp);
        iNumSugeridas++;
    }

    // TRASPOSICION
    for (int i = 0; i < len - 1; i++)
    {
        strcpy(temp, szPalabraLeida);
        char aux = temp[i];
        temp[i] = temp[i + 1];
        temp[i + 1] = aux;

        strcpy(szPalabrasSugeridas[iNumSugeridas], temp);
        iNumSugeridas++;
    }

    // ALFABETO
    char alfabeto[40] = "abcdefghijklmnopqrstuvwxyzñáéíóú";

    // SUSTITUCION
    size_t tam = strlen(alfabeto);
    for (int i = 0; i < len; i++)
    {
        for (int a = 0; a < tam; a++)
        {
            strcpy(temp, szPalabraLeida);
            temp[i] = alfabeto[a];
            temp[len] = '\0';

            strcpy(szPalabrasSugeridas[iNumSugeridas], temp);
            iNumSugeridas++;
        }
    }

    // INSERCION
    for (int pos = 0; pos <= len; pos++)
    {
        for (int a = 0; a < tam; a++)
        {
            int p = 0;

            for (int j = 0; j < pos; j++)
            {
                temp[p] = szPalabraLeida[j];
                p++;
            }

            temp[p] = alfabeto[a];
            p++;

            for (int j = pos; j < len; j++)
            {
                temp[p] = szPalabraLeida[j];
                p++;
            }

            temp[p] = '\0';

            strcpy(szPalabrasSugeridas[iNumSugeridas], temp);
            iNumSugeridas++;
        }
    }

    // ORDEN BURBUJA
    for (int i = 0; i < iNumSugeridas; i++)
    {
        for (int j = 0; j < iNumSugeridas - 1; j++)
        {
            if (strcmp(szPalabrasSugeridas[j], szPalabrasSugeridas[j + 1]) > 0)
            {
                char aux[TAMTOKEN];
                strcpy(aux, szPalabrasSugeridas[j]);
                strcpy(szPalabrasSugeridas[j], szPalabrasSugeridas[j + 1]);
                strcpy(szPalabrasSugeridas[j + 1], aux);
            }
        }
    }
}